<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Spring Bean - Cassie</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="Spring Bean" />
<meta property="og:description" content="Bean的配置 Spring是一个生产和管理其容器内的Bean的工厂，如果要使用这个工厂来生产和管理Bean，需要在Spring的配置文件中配置Bean，Spring框架支持XML和Properties两种格式的配置文件，但是实际中常用的是XML格式的文件。XML配置文件的根元素是 &lt;beans&gt; ，其内包含了多个 &lt;bean&gt; 子元素，每个 &lt;bean&gt; 元素定义一个Bean， 并描述Bean是如何装配到Spring容器中的 。 &lt;bean&gt; 常用属性及其子元素如下表：
   属性或子元素名称 描述     id Bean在Spring中的唯一标识   class Bean的具体实现类   scope 指定Bean的作用域   &lt;constructor-arg&gt; &lt;bean&gt;元素的子元素，使用构造方法注入   &lt;property&gt; &lt;bean&gt;元素的子元素，用于设置一个属性（利用属性的setter方法注入）   &lt;list&gt; &lt;bean&gt;元素的子元素，用于封装List或者数组类型的依赖注入   &lt;map&gt; &lt;bean&gt;元素的子元素，用于封装Map类型的依赖注入   &lt;set&gt; &lt;bean&gt;元素的子元素，用于封装Set类型的依赖注入   &lt;entry&gt; &lt;bean&gt;元素的子元素，用于设置一个键值对    Bean的实例化 在Spring中实例化Bean有三种方式：
 构造方法实例化。 静态工厂实例化。 实例工厂实例化。  构造方法实例化 构造方法实例化就是调用Bean的无参构造器来实例化Bean。只需在指定相应的 &lt;bean&gt; 元素就行了（保证Bean有无参构造器）。一个例子如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cassiestd.github.io/posts/2020-06-06/spring-bean/" />
<meta property="article:published_time" content="2019-11-20T17:16:36+08:00" />
<meta property="article:modified_time" content="2019-11-20T17:16:36+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Spring Bean"/>
<meta name="twitter:description" content="Bean的配置 Spring是一个生产和管理其容器内的Bean的工厂，如果要使用这个工厂来生产和管理Bean，需要在Spring的配置文件中配置Bean，Spring框架支持XML和Properties两种格式的配置文件，但是实际中常用的是XML格式的文件。XML配置文件的根元素是 &lt;beans&gt; ，其内包含了多个 &lt;bean&gt; 子元素，每个 &lt;bean&gt; 元素定义一个Bean， 并描述Bean是如何装配到Spring容器中的 。 &lt;bean&gt; 常用属性及其子元素如下表：
   属性或子元素名称 描述     id Bean在Spring中的唯一标识   class Bean的具体实现类   scope 指定Bean的作用域   &lt;constructor-arg&gt; &lt;bean&gt;元素的子元素，使用构造方法注入   &lt;property&gt; &lt;bean&gt;元素的子元素，用于设置一个属性（利用属性的setter方法注入）   &lt;list&gt; &lt;bean&gt;元素的子元素，用于封装List或者数组类型的依赖注入   &lt;map&gt; &lt;bean&gt;元素的子元素，用于封装Map类型的依赖注入   &lt;set&gt; &lt;bean&gt;元素的子元素，用于封装Set类型的依赖注入   &lt;entry&gt; &lt;bean&gt;元素的子元素，用于设置一个键值对    Bean的实例化 在Spring中实例化Bean有三种方式：
 构造方法实例化。 静态工厂实例化。 实例工厂实例化。  构造方法实例化 构造方法实例化就是调用Bean的无参构造器来实例化Bean。只需在指定相应的 &lt;bean&gt; 元素就行了（保证Bean有无参构造器）。一个例子如下："/>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel="stylesheet">

	<link rel="stylesheet" type="text/css" media="screen" href="https://cassiestd.github.io/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cassiestd.github.io/css/main.css" /><link rel="stylesheet" type="text/css" href="https://cassiestd.github.io/css/dark.css" media="(prefers-color-scheme: dark)" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<script src="https://cassiestd.github.io/js/main.js"></script>
</head>

<body>
	<div class="container wrapper post">
		<div class="header">
	<h1 class="site-title"><a href="https://cassiestd.github.io/">Cassie</a></h1>
	<div class="site-description"><h2>博学精一</h2><nav class="nav social">
			<ul class="flat"><a href="https://github.com/cassiestd" title="Github"><i data-feather="github"></i></a><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">All posts</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post-header">
			<h1 class="title">Spring Bean</h1>
			<div class="meta">Posted at &mdash; Nov 20, 2019</div>
		</div>

		<div class="markdown">
			

<h2 id="bean的配置">Bean的配置</h2>

<p>Spring是一个生产和管理其容器内的Bean的工厂，如果要使用这个工厂来生产和管理Bean，需要在Spring的配置文件中配置Bean，Spring框架支持XML和Properties两种格式的配置文件，但是实际中常用的是XML格式的文件。XML配置文件的根元素是 <code>&lt;beans&gt;</code> ，其内包含了多个 <code>&lt;bean&gt;</code> 子元素，每个 <code>&lt;bean&gt;</code> 元素定义一个Bean， <strong>并描述Bean是如何装配到Spring容器中的</strong> 。 <code>&lt;bean&gt;</code> 常用属性及其子元素如下表：</p>

<table>
<thead>
<tr>
<th>属性或子元素名称</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>id</td>
<td>Bean在Spring中的唯一标识</td>
</tr>

<tr>
<td>class</td>
<td>Bean的具体实现类</td>
</tr>

<tr>
<td>scope</td>
<td>指定Bean的作用域</td>
</tr>

<tr>
<td><code>&lt;constructor-arg&gt;</code></td>
<td><code>&lt;bean&gt;</code>元素的子元素，使用构造方法注入</td>
</tr>

<tr>
<td><code>&lt;property&gt;</code></td>
<td><code>&lt;bean&gt;</code>元素的子元素，用于设置一个属性（利用属性的setter方法注入）</td>
</tr>

<tr>
<td><code>&lt;list&gt;</code></td>
<td><code>&lt;bean&gt;</code>元素的子元素，用于封装List或者数组类型的依赖注入</td>
</tr>

<tr>
<td><code>&lt;map&gt;</code></td>
<td><code>&lt;bean&gt;</code>元素的子元素，用于封装Map类型的依赖注入</td>
</tr>

<tr>
<td><code>&lt;set&gt;</code></td>
<td><code>&lt;bean&gt;</code>元素的子元素，用于封装Set类型的依赖注入</td>
</tr>

<tr>
<td><code>&lt;entry&gt;</code></td>
<td><code>&lt;bean&gt;</code>元素的子元素，用于设置一个键值对</td>
</tr>
</tbody>
</table>

<h2 id="bean的实例化">Bean的实例化</h2>

<p>在Spring中实例化Bean有三种方式：</p>

<ol>
<li>构造方法实例化。</li>
<li>静态工厂实例化。</li>
<li>实例工厂实例化。</li>
</ol>

<h3 id="构造方法实例化">构造方法实例化</h3>

<p>构造方法实例化就是调用Bean的无参构造器来实例化Bean。只需在指定相应的 <code>&lt;bean&gt;</code> 元素就行了（保证Bean有无参构造器）。一个例子如下：</p>

<p>Student实体类的代码如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">public class Student {
    private Integer id,number;
    private String name,sex;
    private Score score;

    public Student() {
        System.out.println(&#34;调用了Student无参构造器~&#34;);
    }

    public Student(Integer id){
        this.id=id;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Integer getNumber() {
        return number;
    }

    public void setNumber(Integer number) {
        this.number = number;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    public Score getScore() {
        return score;
    }

    public void setScore(Score score) {
        this.score = score;
        System.out.println(&#34;使用属性的setter方法完成注入....&#34;);
    }

    @Override
    public String toString() {
        return &#34;Student{&#34; +
                &#34;id=&#34; + id +
                &#34;, number=&#34; + number +
                &#34;, name=&#39;&#34; + name + &#39;\&#39;&#39; +
                &#34;, sex=&#39;&#34; + sex + &#39;\&#39;&#39; +
                &#34;, score=&#34; + score +
                &#39;}&#39;;
    }
}</pre></div>
<p>Score实体类的代码如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">public class Score {
    private Integer id;
    private Float mybatis,mysql,spring;

    public Score(Integer id, Float mybatis, Float mysql, Float spring) {
        this.id = id;
        this.mybatis = mybatis;
        this.mysql = mysql;
        this.spring = spring;
    }

    public Score() {
        System.out.println(&#34;调用了Score的无参构造器~~~&#34;);
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public Float getMybatis() {
        return mybatis;
    }

    public void setMybatis(Float mybatis) {
        this.mybatis = mybatis;
    }

    public Float getMysql() {
        return mysql;
    }

    public void setMysql(Float mysql) {
        this.mysql = mysql;
    }

    public Float getSpring() {
        return spring;
    }

    public void setSpring(Float spring) {
        this.spring = spring;
    }

    @Override
    public String toString() {
        return &#34;Score{&#34; +
                &#34;id=&#34; + id +
                &#34;, mybatis=&#34; + mybatis +
                &#34;, mysql=&#34; + mysql +
                &#34;, spring=&#34; + spring +
                &#39;}&#39;;
    }
}</pre></div>
<p>XML配置文件如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
&lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34;
       xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
       xsi:schemaLocation=&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&#34;&gt;
    &lt;!--将Score交给Spring管理--&gt;
    &lt;bean id=&#34;score&#34; class=&#34;pojo.Score&#34;/&gt;

    &lt;!--将Student交给Spring管理--&gt;
    &lt;bean id=&#34;student&#34; class=&#34;pojo.Student&#34;&gt;
        &lt;property name=&#34;score&#34; ref=&#34;score&#34;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre></div>
<p>测试代码如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">public class Main {
    public static void main(String[] args) {
        ApplicationContext applicationContext =new ClassPathXmlApplicationContext(&#34;spring/applicationContext.xml&#34;);
        Student student=(Student)applicationContext.getBean(&#34;student&#34;);
        System.out.println(student);
    }
}</pre></div>
<p>测试输出如下：</p>

<p><img src="./../media/20191120-1.png" alt="构造器实例" /></p>

<h3 id="静态工厂实例化">静态工厂实例化</h3>

<p>此种方法要求创建一个静态工厂，在XML配置文件种配置 <code>&lt;bean&gt;</code> 的时候，class属性指定静态工厂类，同时 <strong>factory-method属性指定静态工厂类中的静态方法</strong> 。一个案例如下：</p>

<p>静态工厂类代码如下（Student实体和上面的例子一样）：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">public class StudentBeanFactory {
    private static final Student studentBean=new Student();
    public static Student getInstance(){
        return studentBean;
    }
}</pre></div>
<p>XMl配置文件如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
&lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34;
       xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
       xsi:schemaLocation=&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&#34;&gt;
    &lt;bean id=&#34;studentFactory&#34; class=&#34;utils.StudentBeanFactory&#34; factory-method=&#34;getInstance&#34;/&gt;
&lt;/beans&gt;</pre></div>
<p>测试代码如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">public class Main {
    public static void main(String[] args) {
        ApplicationContext applicationContext =new ClassPathXmlApplicationContext(&#34;spring/applicationContext.xml&#34;);
        Student student=(Student)applicationContext.getBean(&#34;studentFactory&#34;);
        System.out.println(student);
    }
}</pre></div>
<p>测试结果如下：</p>

<p><img src="./../media/20191120-2.png" alt="静态工厂实例化" /></p>

<h3 id="实例工厂实例化">实例工厂实例化</h3>

<p>此种方式需要创建一个实例工厂，在XML配置文件中需要配置 <code>&lt;bean&gt;</code> 的 <strong>factory-bean属性指向实例工厂，且factory-method属性指向工厂的实例方法</strong> 。一个例子如下：</p>

<p>实例工厂代码如下（Student实体和上面的例子一样）：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">public class StudentFactory {
    private static final Student instance=new Student();
    public Student getInstance(){
        System.out.println(&#34;调用实例工厂~~&#34;);
        return instance;
    }
}</pre></div>
<p>XML配置文件如下（先利用Spring实例化工厂，再调用实例工厂）：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
&lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34;
       xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
       xsi:schemaLocation=&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&#34;&gt;
    &lt;bean id=&#34;studentFactory&#34; class=&#34;utils.StudentFactory&#34;/&gt;
    &lt;bean id=&#34;student&#34; factory-bean=&#34;studentFactory&#34; factory-method=&#34;getInstance&#34;/&gt;
&lt;/beans&gt;</pre></div>
<p>测试代码如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">public class Main {
    public static void main(String[] args) {
        ApplicationContext applicationContext =new ClassPathXmlApplicationContext(&#34;spring/applicationContext.xml&#34;);
        Student student=(Student)applicationContext.getBean(&#34;student&#34;);
        System.out.println(student);
    }
}</pre></div>
<p>测试结果如下：</p>

<p><img src="./../media/20191120-3.png" alt="实例工厂实例化" /></p>

<h2 id="bean的作用域">Bean的作用域</h2>

<p>Bean的作用域详情如下表：</p>

<table>
<thead>
<tr>
<th>作用域名称</th>
<th>描述</th>
</tr>
</thead>

<tbody>
<tr>
<td>singleton</td>
<td>默认的作用域，使用此定义域的Bean在Spring容器中<strong>只有一个Bean实例</strong></td>
</tr>

<tr>
<td>property</td>
<td>Spring容器每次获取property定义的Bean，容器都将创建一个新的Bean实例</td>
</tr>

<tr>
<td>request</td>
<td>在一次HTTP请求中，容器将返回一个Bean实例，不同的HTTP请求返回不同的Bean实例</td>
</tr>

<tr>
<td>session</td>
<td>在一个HTTP Session中，容器将返回同一个Bean实例</td>
</tr>

<tr>
<td>application</td>
<td>为每个ServletContext对象创建一个实例，同一个应用共享一个Bean实例</td>
</tr>

<tr>
<td>websocket</td>
<td>为每个WebSocket对象创建一个Bean实例</td>
</tr>
</tbody>
</table>

<h2 id="bean的装配方式">Bean的装配方式</h2>

<p>Bean的装配就是Bean依赖注入的方式，Spring容器支持基于XML配置的装配、基于注解的装配以及自动装配等多种方式。最常用的就是基于注解的装配。</p>

<h3 id="基于xml配置的装配">基于XML配置的装配</h3>

<p>在<a href="https://p1n93r.github.io/post/spring/spring-ioc/">Spring Ioc</a>的“依赖注入的类型”中提到了简单的基于XML配置的装配，接下来一个复杂的综合案例如下：</p>

<p>一个实体类代码如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">public class Test {
    private String commonAttr;
    private List&lt;Integer&gt; listAttr;
    private Set&lt;String&gt; setAttr;
    private Map&lt;Integer,String&gt; mapAttr;
    private String[] arrayAttr;

    public Test(){}

    public Test(String commonAttr, List&lt;Integer&gt; listAttr, Set&lt;String&gt; setAttr, Map&lt;Integer, String&gt; mapAttr, String[] arrayAttr) {
        this.commonAttr = commonAttr;
        this.listAttr = listAttr;
        this.setAttr = setAttr;
        this.mapAttr = mapAttr;
        this.arrayAttr = arrayAttr;
    }

    public String getCommonAttr() {
        return commonAttr;
    }

    public void setCommonAttr(String commonAttr) {
        this.commonAttr = commonAttr;
    }

    public List&lt;Integer&gt; getListAttr() {
        return listAttr;
    }

    public void setListAttr(List&lt;Integer&gt; listAttr) {
        this.listAttr = listAttr;
    }

    public Set&lt;String&gt; getSetAttr() {
        return setAttr;
    }

    public void setSetAttr(Set&lt;String&gt; setAttr) {
        this.setAttr = setAttr;
    }

    public Map&lt;Integer, String&gt; getMapAttr() {
        return mapAttr;
    }

    public void setMapAttr(Map&lt;Integer, String&gt; mapAttr) {
        this.mapAttr = mapAttr;
    }

    public String[] getArrayAttr() {
        return arrayAttr;
    }

    public void setArrayAttr(String[] arrayAttr) {
        this.arrayAttr = arrayAttr;
    }

    @Override
    public String toString() {
        return &#34;Test{&#34; +
                &#34;commonAttr=&#39;&#34; + commonAttr + &#39;\&#39;&#39; +
                &#34;, listAttr=&#34; + listAttr +
                &#34;, setAttr=&#34; + setAttr +
                &#34;, mapAttr=&#34; + mapAttr +
                &#34;, arrayAttr=&#34; + Arrays.toString(arrayAttr) +
                &#39;}&#39;;
    }
}</pre></div>
<p>XML配置文件如下（演示了了构造器注入和setter注入）：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
&lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34;
       xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
       xsi:schemaLocation=&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&#34;&gt;
    &lt;!--利用构造器注入--&gt;
    &lt;bean id=&#34;test&#34; class=&#34;pojo.Test&#34;&gt;
        &lt;constructor-arg index=&#34;0&#34; value=&#34;我是stringAttr&#34;/&gt;
        &lt;constructor-arg index=&#34;1&#34;&gt;
            &lt;list value-type=&#34;java.lang.Integer&#34;&gt;
                &lt;value&gt;3&lt;/value&gt;
                &lt;value&gt;2&lt;/value&gt;
                &lt;value&gt;1&lt;/value&gt;
            &lt;/list&gt;
        &lt;/constructor-arg&gt;
        &lt;constructor-arg index=&#34;2&#34;&gt;
            &lt;set value-type=&#34;java.lang.String&#34;&gt;
                &lt;value&gt;嘻嘻&lt;/value&gt;
                &lt;value&gt;哈哈&lt;/value&gt;
                &lt;value&gt;我是setAttr&lt;/value&gt;
            &lt;/set&gt;
        &lt;/constructor-arg&gt;
        &lt;constructor-arg index=&#34;3&#34;&gt;
            &lt;map key-type=&#34;java.lang.Integer&#34; value-type=&#34;java.lang.String&#34;&gt;
                &lt;entry key=&#34;0&#34; value=&#34;what&#34;/&gt;
                &lt;entry key=&#34;1&#34; value=&#34;where&#34;/&gt;
                &lt;entry key=&#34;2&#34; value=&#34;which&#34;/&gt;
            &lt;/map&gt;
        &lt;/constructor-arg&gt;
        &lt;constructor-arg index=&#34;4&#34;&gt;
            &lt;array value-type=&#34;java.lang.String&#34;&gt;
                &lt;value&gt;曾经沧海&lt;/value&gt;
                &lt;value&gt;再难为水&lt;/value&gt;
            &lt;/array&gt;
        &lt;/constructor-arg&gt;
    &lt;/bean&gt;
    &lt;!--利用属性的setter方式注入--&gt;
    &lt;bean id=&#34;test1&#34; class=&#34;pojo.Test&#34;&gt;
        &lt;property name=&#34;commonAttr&#34; value=&#34;我是commonAttr&#34;/&gt;
        &lt;property name=&#34;listAttr&#34;&gt;
            &lt;list value-type=&#34;java.lang.Integer&#34;&gt;
                &lt;value&gt;1&lt;/value&gt;
                &lt;value&gt;2&lt;/value&gt;
                &lt;value&gt;3&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;property name=&#34;setAttr&#34;&gt;
            &lt;set value-type=&#34;java.lang.String&#34;&gt;
                &lt;value&gt;我是setAttr&lt;/value&gt;
                &lt;value&gt;哈哈&lt;/value&gt;
                &lt;value&gt;嘻嘻&lt;/value&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;property name=&#34;mapAttr&#34;&gt;
            &lt;map key-type=&#34;java.lang.Integer&#34; value-type=&#34;java.lang.String&#34;&gt;
                &lt;entry key=&#34;0&#34; value=&#34;giao!&#34;/&gt;
                &lt;entry key=&#34;1&#34; value=&#34;huohuo!&#34;/&gt;
                &lt;entry key=&#34;2&#34; value=&#34;wow!&#34;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name=&#34;arrayAttr&#34;&gt;
            &lt;array value-type=&#34;java.lang.String&#34;&gt;
                &lt;value&gt;曾经沧海难为水&lt;/value&gt;
                &lt;value&gt;除却巫山不是云&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre></div>
<p>测试代码如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">public class Main {
    public static void main(String[] args) {
        ApplicationContext applicationContext =new ClassPathXmlApplicationContext(&#34;spring/applicationContext.xml&#34;);
        Test test=(Test)applicationContext.getBean(&#34;test&#34;);
        System.out.println(test);
        Test test1=(Test)applicationContext.getBean(&#34;test1&#34;);
        System.out.println(test1);
    }
}</pre></div>
<p>测试结果如下：</p>

<p><img src="./../media/20191120-4.png" alt="XMl装配" /></p>

<h3 id="基于注解的装配">基于注解的装配</h3>

<p>如果应用中有大量的Bean，则通过XML装配方式则会显得麻烦，所以推荐使用基于注解的装配方式。以下是Spring中常用的几种注解：</p>

<ol>
<li>@Component：表示一个组件对象（Bean），可以作用于任何层次上。只能注入简单的值，对于复杂的注入目前使用此种方式无法解决。</li>
<li>@Repository：该注解用于将数据访问层（DAO）的类标识为Bean，其功能和@Component相同。</li>
<li>@Service：该注解用于标注一个业务逻辑层类（Service层），其功能和@Component相同。</li>
<li>@Controller：该注解用于标注一个控制器组件类（SpringMVC的Controller），其功能和@Component相同。</li>
<li>@Autowired：该注解可以 <strong>对成员变量、方法及构造器进行标注，完成自动装配的工作</strong> 。通过使用该注解来消除setter和getter方法。 <strong>默认按照Bean的类型进行装配</strong> 。</li>
<li>@Resource：和@Autowired的功能一样， <strong>区别是该注解默认按照名称来装配注入</strong> ，只有当找不到名称匹配的Bean时才会按照类型来装配注入。@Resource有两个属性：name和type，name指定Bean的实例名称、type指定Bean的类型。</li>
<li>@Qualifier：该注解和@Autowired注解配合使用。当@Autowired注解需要按照名称来装配注入时，需要配合该注解一起使用，Bean的实例名称由@Qualifier注解的参数指定。</li>
</ol>

<p><strong><em>Notice</em></strong>：在Spring4.0以上的版本中，配置注解指定包中的注解进行扫描前需要事先导入Spring AOP的Jar包。</p>

		</div>

		<div class="post-tags">
			
				
			
		</div><div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = 'cassie_std';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
		Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> © Copyright notice |  <a href="https://github.com/vividvilla/ezhil">Ezhil theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>

<script>feather.replace()</script>
</body>
</html>
