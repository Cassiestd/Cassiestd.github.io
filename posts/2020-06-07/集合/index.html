<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>集合 - Cassie</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta property="og:title" content="集合" />
<meta property="og:description" content="概述  集合类也被称为 容器 ，所有的集合都位于java.util包下。 集合类家族主要由Collection和Map接口派生出。 集合相比数组的优势是：长度可变，且能存储不同类型的对象。Map还能存储映射关系。 集合只能存储对象，不能存储基本类型的值。 Set代表无序不可重复，List代表有序可重复，Map代表无序不可重复键值的映射，Queue代表队列集合。  Collection的家谱如下图：
Map的家谱如下图：
Collection和Iterator Collection是Set、List和Queue父接口，此接口定义了一些操作结合元素的基本方法。可以查看Java8的api文档。此外，Collection定义了一个返回迭代器的方法iterator(),返回一个Iterator类型的迭代器，Iterator必须依赖于Collection对象，迭代器主要如下有三个方法：
 boolean hasNext():如果被迭代的集合元素还没有被遍历，则返回true。 Object next():返回集合里的下一个迭代对象。 void remove():删除集合里上一次next方法返回的元素。  一个Iterator的使用例子如下（也包括了foreach的使用）：
@Test public void test_1(){ List&lt;String&gt; a=new ArrayList&lt;&gt;(); for(int i=0;i&lt;5;i&#43;&#43;){ a.add(&#34;我是&#34;&#43;i); } Iterator&lt;String&gt; iterator=a.iterator(); while(iterator.hasNext()){ String temp=iterator.next(); if(temp.equals(&#34;我是2&#34;)){ iterator.remove(); } System.out.println(temp); } System.out.println(&#34;------------分割线---------------&#34;); for(String v:a){ System.out.println(v); } } 输出结果如下图：
Notice: Iterator方式和foreach方式迭代过程中，不能直接对集合进行改变，否则会报错： java.util.ConcurrentModificationException ,所有的内部基于数组来实现的集合，最好用随机访问，其他的采用迭代访问。
Set集合 Set判断两个对象相等的原则是：两个对象用equals方法返回true。在此基础上再来了解HashSet、SortedSet、LinkedHashSet。
HashSet  HashSet判断两个对象是否相等的条件是： 两个对象通过equals()方法返回true且两者的hashCode()方法返回值相等。 此外，如果两个对象的equals()返回false，但hashCode()返回的值相同，HashSet会将两个对象存储在相同的位置，使用链表结构保存，会导致性能下降。 HashSet按照Hash算法来存储集合中的元素，具有 很好的存取和查找性能。 多个线程同时访问HashSet需要通过代码保证其同步。 集合元素可以为null 需要被保存到HashSet中的对象，需要重写其equals()和hashCode()方法，保证两者通过equals()方法返回为true时，两者的hashCode()方法返回也相同。 当HashSet中存储了对象时，此时再修改它，可能会导致它与其他对象相等（值相等），此时会导致HashSet无法准确的访问元素。  一个例子如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cassiestd.github.io/posts/2020-06-07/%E9%9B%86%E5%90%88/" />
<meta property="article:published_time" content="2019-10-18T19:50:36+08:00" />
<meta property="article:modified_time" content="2019-10-18T19:50:36+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="集合"/>
<meta name="twitter:description" content="概述  集合类也被称为 容器 ，所有的集合都位于java.util包下。 集合类家族主要由Collection和Map接口派生出。 集合相比数组的优势是：长度可变，且能存储不同类型的对象。Map还能存储映射关系。 集合只能存储对象，不能存储基本类型的值。 Set代表无序不可重复，List代表有序可重复，Map代表无序不可重复键值的映射，Queue代表队列集合。  Collection的家谱如下图：
Map的家谱如下图：
Collection和Iterator Collection是Set、List和Queue父接口，此接口定义了一些操作结合元素的基本方法。可以查看Java8的api文档。此外，Collection定义了一个返回迭代器的方法iterator(),返回一个Iterator类型的迭代器，Iterator必须依赖于Collection对象，迭代器主要如下有三个方法：
 boolean hasNext():如果被迭代的集合元素还没有被遍历，则返回true。 Object next():返回集合里的下一个迭代对象。 void remove():删除集合里上一次next方法返回的元素。  一个Iterator的使用例子如下（也包括了foreach的使用）：
@Test public void test_1(){ List&lt;String&gt; a=new ArrayList&lt;&gt;(); for(int i=0;i&lt;5;i&#43;&#43;){ a.add(&#34;我是&#34;&#43;i); } Iterator&lt;String&gt; iterator=a.iterator(); while(iterator.hasNext()){ String temp=iterator.next(); if(temp.equals(&#34;我是2&#34;)){ iterator.remove(); } System.out.println(temp); } System.out.println(&#34;------------分割线---------------&#34;); for(String v:a){ System.out.println(v); } } 输出结果如下图：
Notice: Iterator方式和foreach方式迭代过程中，不能直接对集合进行改变，否则会报错： java.util.ConcurrentModificationException ,所有的内部基于数组来实现的集合，最好用随机访问，其他的采用迭代访问。
Set集合 Set判断两个对象相等的原则是：两个对象用equals方法返回true。在此基础上再来了解HashSet、SortedSet、LinkedHashSet。
HashSet  HashSet判断两个对象是否相等的条件是： 两个对象通过equals()方法返回true且两者的hashCode()方法返回值相等。 此外，如果两个对象的equals()返回false，但hashCode()返回的值相同，HashSet会将两个对象存储在相同的位置，使用链表结构保存，会导致性能下降。 HashSet按照Hash算法来存储集合中的元素，具有 很好的存取和查找性能。 多个线程同时访问HashSet需要通过代码保证其同步。 集合元素可以为null 需要被保存到HashSet中的对象，需要重写其equals()和hashCode()方法，保证两者通过equals()方法返回为true时，两者的hashCode()方法返回也相同。 当HashSet中存储了对象时，此时再修改它，可能会导致它与其他对象相等（值相等），此时会导致HashSet无法准确的访问元素。  一个例子如下："/>
<link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel="stylesheet">

	<link rel="stylesheet" type="text/css" media="screen" href="https://cassiestd.github.io/css/normalize.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="https://cassiestd.github.io/css/main.css" /><link rel="stylesheet" type="text/css" href="https://cassiestd.github.io/css/dark.css" media="(prefers-color-scheme: dark)" />

	<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<script src="https://cassiestd.github.io/js/main.js"></script>
</head>

<body>
	<div class="container wrapper post">
		<div class="header">
	<h1 class="site-title"><a href="https://cassiestd.github.io/">Cassie</a></h1>
	<div class="site-description"><h2>博学精一</h2><nav class="nav social">
			<ul class="flat"><a href="https://github.com/cassiestd" title="Github"><i data-feather="github"></i></a><a href="/index.xml" title="RSS"><i data-feather="rss"></i></a></ul>
		</nav>
	</div>

	<nav class="nav">
		<ul class="flat">
			
			<li>
				<a href="/">Home</a>
			</li>
			
			<li>
				<a href="/posts">All posts</a>
			</li>
			
			<li>
				<a href="/about">About</a>
			</li>
			
			<li>
				<a href="/tags">Tags</a>
			</li>
			
		</ul>
	</nav>
</div>


		<div class="post-header">
			<h1 class="title">集合</h1>
			<div class="meta">Posted at &mdash; Oct 18, 2019</div>
		</div>

		<div class="markdown">
			

<h2 id="概述">概述</h2>

<ul>
<li>集合类也被称为 <strong>容器</strong> ，所有的集合都位于java.util包下。</li>
<li>集合类家族主要由Collection和Map接口派生出。</li>
<li>集合相比数组的优势是：长度可变，且能存储不同类型的对象。Map还能存储映射关系。</li>
<li><strong>集合只能存储对象，不能存储基本类型的值。</strong></li>
<li>Set代表无序不可重复，List代表有序可重复，Map代表无序不可重复键值的映射，Queue代表队列集合。</li>
</ul>

<p>Collection的家谱如下图：</p>

<p><img src="./../media/20191018-1.png" alt="Collection家谱" /></p>

<p>Map的家谱如下图：</p>

<p><img src="./../media/20191018-2.png" alt="Map家谱" /></p>

<h2 id="collection和iterator">Collection和Iterator</h2>

<p>Collection是Set、List和Queue父接口，此接口定义了一些操作结合元素的基本方法。可以查看Java8的api文档。此外，Collection定义了一个返回迭代器的方法iterator(),返回一个Iterator类型的迭代器，Iterator必须依赖于Collection对象，迭代器主要如下有三个方法：</p>

<ol>
<li>boolean hasNext():如果被迭代的集合元素还没有被遍历，则返回true。</li>
<li>Object next():返回集合里的下一个迭代对象。</li>
<li>void remove():删除集合里上一次next方法返回的元素。</li>
</ol>

<p>一个Iterator的使用例子如下（也包括了foreach的使用）：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">@Test
public void test_1(){
    List&lt;String&gt; a=new ArrayList&lt;&gt;();
    for(int i=0;i&lt;5;i++){
        a.add(&#34;我是&#34;+i);
    }
    Iterator&lt;String&gt; iterator=a.iterator();
    while(iterator.hasNext()){
        String temp=iterator.next();
        if(temp.equals(&#34;我是2&#34;)){
            iterator.remove();
        }
        System.out.println(temp);
    }
    System.out.println(&#34;------------分割线---------------&#34;);
    for(String v:a){
        System.out.println(v);
    }
}</pre></div>
<p>输出结果如下图：</p>

<p><img src="./../media/20191018-3.png" alt="结果1" /></p>

<p><strong><em>Notice:</em></strong> Iterator方式和foreach方式迭代过程中，不能直接对集合进行改变，否则会报错： <code>java.util.ConcurrentModificationException</code> ,所有的内部基于数组来实现的集合，最好用随机访问，其他的采用迭代访问。</p>

<h2 id="set集合">Set集合</h2>

<p>Set判断两个对象相等的原则是：两个对象用equals方法返回true。在此基础上再来了解HashSet、SortedSet、LinkedHashSet。</p>

<h3 id="hashset">HashSet</h3>

<ul>
<li>HashSet判断两个对象是否相等的条件是： <strong>两个对象通过equals()方法返回true且两者的hashCode()方法返回值相等。</strong> 此外，如果两个对象的equals()返回false，但hashCode()返回的值相同，HashSet会将两个对象存储在相同的位置，使用链表结构保存，会导致性能下降。</li>
<li>HashSet按照Hash算法来存储集合中的元素，具有 <strong>很好的存取和查找性能。</strong></li>
<li>多个线程同时访问HashSet需要通过代码保证其同步。</li>
<li><strong>集合元素可以为null</strong></li>
<li>需要被保存到HashSet中的对象，需要重写其equals()和hashCode()方法，保证两者通过equals()方法返回为true时，两者的hashCode()方法返回也相同。</li>
<li>当HashSet中存储了对象时，此时再修改它，可能会导致它与其他对象相等（值相等），此时会导致HashSet无法准确的访问元素。</li>
</ul>

<p>一个例子如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><span style="color:#719e07">package</span> com.test.commonClass;
<span style="color:#719e07">import</span> java.util.HashSet;
<span style="color:#719e07">import</span> java.util.Set;

public class R {
    private <span style="color:#dc322f">int</span> count;
    public <span style="color:#268bd2">R</span>(<span style="color:#dc322f">int</span> count){
        this.count=count;
    }
    @Override
    public String <span style="color:#268bd2">toString</span>(){
        <span style="color:#719e07">return</span> <span style="color:#2aa198">&#34;R[count:&#34;</span><span style="color:#719e07">+</span>count<span style="color:#719e07">+</span><span style="color:#2aa198">&#34;]&#34;</span>;
    }
    @Override
    public <span style="color:#dc322f">int</span> <span style="color:#268bd2">hashCode</span>(){
        <span style="color:#719e07">return</span> this.count;
    }
    @Override
    public boolean <span style="color:#268bd2">equals</span>(Object obj){
        <span style="color:#719e07">if</span>(obj<span style="color:#719e07">==</span>this){
            <span style="color:#719e07">return</span> <span style="color:#cb4b16">true</span>;
        }<span style="color:#719e07">else</span>{
            <span style="color:#719e07">if</span>(obj<span style="color:#719e07">!=</span>null<span style="color:#719e07">&amp;&amp;</span>obj.<span style="color:#268bd2">getClass</span>()<span style="color:#719e07">==</span>this.<span style="color:#268bd2">getClass</span>()){
                R temp=(R)obj;
                <span style="color:#719e07">return</span> temp.<span style="color:#268bd2">getCount</span>()<span style="color:#719e07">==</span>this.<span style="color:#268bd2">getCount</span>()? <span style="color:#cb4b16">true</span>:<span style="color:#cb4b16">false</span>;
            }
        }
        <span style="color:#719e07">return</span> <span style="color:#cb4b16">false</span>;
    }
    public <span style="color:#dc322f">int</span> <span style="color:#268bd2">getCount</span>() {
        <span style="color:#719e07">return</span> count;
    }
    public void <span style="color:#268bd2">setCount</span>(<span style="color:#dc322f">int</span> count) {
        this.count = count;
    }
    public static void <span style="color:#268bd2">main</span>(String[] args){
        Set&lt;R&gt; set=new HashSet&lt;&gt;();
        R a=new <span style="color:#268bd2">R</span>(<span style="color:#2aa198">1</span>);
        set.<span style="color:#268bd2">add</span>(a);
        set.<span style="color:#268bd2">add</span>(new <span style="color:#268bd2">R</span>(<span style="color:#2aa198">2</span>));
        set.<span style="color:#268bd2">add</span>(new <span style="color:#268bd2">R</span>(<span style="color:#2aa198">3</span>));
        System.out.<span style="color:#b58900">println</span>(set);
        <span style="color:#586e75">//现在改变count为1的那个元素
</span><span style="color:#586e75"></span>        a.<span style="color:#268bd2">setCount</span>(<span style="color:#2aa198">3</span>);
        System.out.<span style="color:#b58900">println</span>(set);
        <span style="color:#586e75">//现在删除count为3的元素，将hash命中定位到第三个元素，所以删除第三个元素
</span><span style="color:#586e75"></span>        set.<span style="color:#268bd2">remove</span>(new <span style="color:#268bd2">R</span>(<span style="color:#2aa198">3</span>));
        System.out.<span style="color:#b58900">println</span>(set);
        <span style="color:#586e75">//此时虽然打印出的结果中，在第一个元素那有一个count为3的元素，但是我们去找到它已经找不到了
</span><span style="color:#586e75"></span>        System.out.<span style="color:#b58900">println</span>(<span style="color:#2aa198">&#34;是否还有count为3的元素&#34;</span><span style="color:#719e07">+</span>set.<span style="color:#268bd2">contains</span>(new <span style="color:#268bd2">R</span>(<span style="color:#2aa198">3</span>)));
        System.out.<span style="color:#b58900">println</span>(<span style="color:#2aa198">&#34;是否还有count为1的元素&#34;</span><span style="color:#719e07">+</span>set.<span style="color:#268bd2">contains</span>(new <span style="color:#268bd2">R</span>(<span style="color:#2aa198">1</span>)));
    }
}</pre></div>
<p>输出结果如下图：</p>

<p><img src="./../media/20191018-4.png" alt="结果2" /></p>

<h3 id="lindedhashset">LindedHashSet</h3>

<ul>
<li>LindedHashSet是HashSet的子类，也是根据元素的hash值来决定元素的存储位置。</li>
<li>LindedHashSet以链表结构维护元素的次序，所以 <strong>元素是有序的</strong> ，顺序是其添加顺序。</li>
<li>LinkedHashSet性能略低于HashSet，<strong>但是迭代访问将会有很好的性能</strong>。</li>
</ul>

<h3 id="treeset">TreeSet</h3>

<ul>
<li><strong>TreeSet判断两个对象是否相等的依据是（自然排序时）：两者通过compareTo()方法返回0，但是为了照顾常规思维，也得保证此时两者通过equals()方法返回true且hashCode()方法返回值相等。</strong></li>
<li>TreeSet是SortedSet接口的实现类，其集合元素处于排序状态。</li>
<li>TreeSet还提供了返回第一个，最后一个，前一个，后一个元素方法；还有截取集合获得子集的方法。</li>
<li>TreeSet可以使用 <strong>定制排序和自然排序。</strong> 默认情况采用自然排序。</li>
<li>TreeSet采用 <strong>红黑树的数据结构来存储集合元素。</strong></li>
<li>添加到TreeSet中的元素必须是 <strong>同样的数据类型的对象。</strong></li>
</ul>

<h4 id="自然排序">自然排序</h4>

<p>自然排序要求元素的类实现了 <code>Comparable</code> 接口的 <code>compareTo(Object obj)</code> 方法。实现了该接口的类的对象就可以进行大小比较。例如 <code>obj.compareTo(obj1)</code> 的结果，如果返回0，则代表两者相等；如果返回正整数，则代表obj大于obj1；如果返回一个负整数，则代表obj小于obj1；常见的实现了Comparable接口的类如下：</p>

<ul>
<li>Character：按照字符的UNICODE值进行比较。</li>
<li>Boolean：true对应的包装类实例大于false对应的包装类实例。</li>
<li>String：按照字符串中字符的UNICODE值进行比较。</li>
<li>Date、Time：后面的日期和时间比前面的日期和时间要大。</li>
</ul>

<p>往TreeSet中加入元素要么需要定制排序，要么需要自然排序。而自然排序就是待加入元素的类需要实现 <code>Comparable</code> 接口的 <code>compareTo(Object obj)</code> 方法。如果使用自然排序，但是其元素没有实现Comparable接口，添加第一个元素时不会报错，但是第二个元素会报错（第二个元素需要与第一个元素进行比较，此时两者不能进行比较从而报错）。此外需要注意的地方如下：</p>

<ol>
<li>就算两个对象都实现了Comparable接口，但是不是同一个类型的对象，也不能被添加到TreeSet。</li>
<li>加入到TreeSet中的对象最好是不可变对象，防止其属性被修改而导致查找元素时的比较出问题（只能查找到没有改变且不与其他改变后导致与自己重复的元素）。</li>
</ol>

<h4 id="定制排序">定制排序</h4>

<p>实例化一个TreeSet的时候可以传入一个匿名对象，此匿名对象是Comparator接口的实例。一个例子如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">public class TreeSetTest {
    @Test
    public void test1(){
        TreeSet&lt;R&gt; rs = new TreeSet&lt;&gt;(new Comparator&lt;R&gt;() {
            @Override
            public int compare(R o1, R o2) {
                return o1.getCount() == o2.getCount() ? 0 : o1.getCount() &gt; o2.getCount() ? 1 : -2;
            }
        });
        rs.add(new R(-3));
        rs.add(new R(4));
        rs.add(new R(-2));
        rs.add(new R(1));
        rs.add(new R(3));
        //输出：[R[count:-3], R[count:-2], R[count:1], R[count:3], R[count:4]]
        System.out.println(rs);
    }
}</pre></div>
<p><strong><em>Notice</em></strong>：此种方法同样不能在TreeSet中添加不同类型的元素。</p>

<h3 id="各个set实现类比较">各个Set实现类比较</h3>

<ol>
<li>HashSet的性能总是比TreeSet好，尤其是插入和查找操作。只有当需要一个保持排序的Set时，才使用TreeSet。</li>
<li>HashSet的子类LinkedHashSet，对于删除和插入操作，比HashSet慢一点（维护链表带来的额外开销造成的），不过因为是链表，所以遍历LinkedHashSet会更快。</li>
<li>总而言之：<strong>需要排序的Set，用TreeSet；一般使用HashSet；经常遍历的用LinkedHashSet。</strong></li>
</ol>

<h2 id="list集合">List集合</h2>

<p>List接口比Collection接口的迭代器多了反向迭代的功能。List集合代表有序可重复的集合，每个元素都有其对应的顺序索引。此外与Set集合相比，多了根据索引来插入，删除，替换的方法。List判断两个对象是否相等的前提是两者通过equals()方法返回true。一个例子如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">class R{
    @Override
    public boolean equals(Object obj){
        //无论与谁相比都是true
        return true;
    }
}
public class ListTest {
    @Test
    public void test1(){
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        list.add(&#34;落霞与孤鹜齐飞&#34;);
        list.add(&#34;秋水共长天一色&#34;);
        //因为R类的对象与谁通过equals()比较都是true，所以会输出true
        System.out.println(list.contains(new R()));
        //输出：[落霞与孤鹜齐飞, 秋水共长天一色]
        System.out.println(list);
        //当R对象与list的第一个元素通过equals()比较时，返回true，所以会在第一元素删除它
        list.remove(new R());
        //输出：[秋水共长天一色]
        System.out.println(list);
        //同上次的remove()一样，会在比较第一个元素时就把它删除了，所以下面将输出空的List集合
        list.remove(new R());
        //输出：[]
        System.out.println(list);
    }
}</pre></div>
<h3 id="listiterator">ListIterator</h3>

<p>与Set不同的是，List提供一个可以反向迭代的ListIterator迭代器。该接口继承于Iterator接口，在其基础上增加了如下方法：</p>

<ol>
<li>boolean hasPrevious()：该迭代器关联的集合是否有上一个元素。</li>
<li>Object previous()：返回该迭代器的上一个元素。</li>
<li>void add()：在指定位置插入一个元素。</li>
</ol>

<p>一个使用例子如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">@Test
public void test2(){
    ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
    list.add(&#34;落霞与孤鹜齐飞&#34;);
    list.add(&#34;秋水共长天一色&#34;);
    list.add(&#34;关山难越&#34;);
    list.add(&#34;谁背失路之人&#34;);
    list.add(&#34;哀吾生之须臾&#34;);
    list.add(&#34;羡长江之无穷&#34;);
    ListIterator&lt;String&gt; iterator=list.listIterator();
    while(iterator.hasNext()){
        System.out.println(iterator.next());
    }
    //接下来反向迭代（先正向迭代，指针到了后面才能反向迭代）
    while(iterator.hasPrevious()){
        System.out.println(iterator.previous());
    }
}</pre></div>
<p>输出截图如下：</p>

<p><img src="./../media/20191022-1.png" alt="结果3" /></p>

<h3 id="arraylist">ArrayList</h3>

<p>ArrayList是一个基于数组的实现的List类，所以随机访问性能比较好。虽然ArrayList相对数组而言，可以动态的改变元素的个数，但是其实实例化时，也可以指定ArrayList的个数（不指定默认为10）。后面如果超出了这个数量，则会动态分配大小，但是如果提前就知道了需要存储比较多的元素时，可以直接调用ArrayList的 <code>ensureCapacity()</code> 方法来一次性地增加initialCapacity，可以减少重新分配的次数，从而提高性能。此外，可以调用 <code>trimToSize()</code> 方法来调整其内部的数组长度为当前元素个数，从而减少了ArrayList占用的空间。一个实例代码如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">@Test
public void test3(){
    //实例化时指定List集合的initialCapacity，长度超出时会自动增长。
    //如果不写，默认为10
    ArrayList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;(10);
    ArrayList&lt;String&gt; list2 = new ArrayList&lt;&gt;();
    //当一开始不知道需要多大的List空间时，可以之后利用其ensureCapacity()方法来指定其元素个数
    //这样避免总是自动分配，提高性能
    list2.ensureCapacity(100);
    for(int i=0;i&lt;40;i++){
        list2.add(String.valueOf(i));
    }
    list2.trimToSize();
}</pre></div>
<p>此外还有一个不可变长度的ArrayList，就是Arrays.ArrayList类（这个ArrayList是Arrays的内部类），可以通过调用Arrays的asList()方法来将一个数组转换成其内部类ArraysList的对象。此对象不可添加和删除元素。实例代码如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">@Test
public void test4(){
    String[] a=new String[]{&#34;one&#34;,&#34;two&#34;,&#34;three&#34;};
    List&lt;String&gt; list = Arrays.asList(a);
    //下面的操作会报错
    System.out.println(list.add(&#34;four&#34;)+&#34;,&#34;+list.remove(&#34;one&#34;));
}</pre></div>
<h2 id="queue集合">Queue集合</h2>

<p>Queue主要是为了模拟队列这种数据结构。常用到的有Deque接口的实现类ArrayDeque和LinkedDeque。Deque代表双端队列，如果需要使用到栈这种数据结构，推荐使用ArrayDeque和LinkedDeque。前者随机访问性能比较好，后者迭代访问性能比较好。两者主要方法可以查看api文档。</p>

<h2 id="map集合">Map集合</h2>

<p>Map就是存储具有映射关系的数据，就是所谓的键值对。Map的key不允许重复，但是允许为null（也只能存在一个）。Map判断键值对的key相等的规则也是两者通过equals()方法返回true则认为它们相等。其实Java是先实现了Map再实现了Set，Set就是键值对中值为null的Map。Map接口常用方法如下：</p>

<ul>
<li>Set entrySet()：返回Map中包含的键值对所组成的Set集合，每个集合元素都是Map.Entry对象。</li>
<li>boolean isEmpty()：判断此Map是否为空。</li>
<li>Set keySet()：返回该Map中所有key组成的Set集合。</li>
<li>Collection values()：返回该Map中所有键值对的值组成的Collection。</li>
</ul>

<p>其中Map.Entry的主要几个方法如下：</p>

<ul>
<li>Object getKey()：返回该键值对的键。</li>
<li>Object getValue()：返回该键值对的值。</li>
<li>Object setValue()：设置该键值对的值，并返回新设置的值。</li>
</ul>

<h3 id="hashmap">HashMap</h3>

<ul>
<li>Map接口常用的实现类就是HashMap了，但 <strong>它不是一个线程安全的类，</strong> 可以使用Collections工具类将HashMap变成线程安全来使用。</li>
<li>HashMap允许最多存在一个键为null的键值对（也允许将键值对的值设置为null，这个允许多个）</li>
<li>存放在HashMap中的键值对的键必须实现equals()和hashCode()方法，保证两者通过equals()方法返回true时，两者的hashCode()返回的值相等。</li>
<li>HashMap键值对的值相等的原则是两者通过equals()方法返回true。</li>
<li>尽量不要使用可变对象作为HashMap的键。</li>
</ul>

<p>一个HashMap有关的综合例子如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">@Test
public void test5(){
    Map&lt;String,Integer&gt; map=new HashMap&lt;&gt;();
    System.out.println(map.put(&#34;嘻嘻&#34;,0));
    System.out.println(map.put(new String(&#34;哈哈&#34;),1));
    //已存在“哈哈”键的映射，此时将会替换旧值，并返回旧值（没有发生替换是返回的是null）
    System.out.println(map.put(new String(&#34;哈哈&#34;),2));
    //存放键为null的映射
    System.out.println(map.put(null,3));
    //存放值为null的映射
    System.out.println(map.put(&#34;哇呜&#34;,null));
    //再次放入一个已存在键的映射，任然会替换这个键的值，返回被替换的旧值
    System.out.println(map.put(null,4));
    System.out.println(&#34;Map大小：&#34;+map.size());
    System.out.println(&#34;Map元素：&#34;+map);

    Set&lt;Map.Entry&lt;String, Integer&gt;&gt; entries = map.entrySet();
    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entries.iterator();
    System.out.println(&#34;-----------------遍历HashMap方式一：通过Entry（速度最快）------------------&#34;);
    while(iterator.hasNext()){
        Map.Entry tmp=iterator.next();
        System.out.println(tmp.getKey()+&#34;::::&#34;+tmp.getValue());
    }
    System.out.println(&#34;---------------遍历HashMap方式二：利用keySet（折中了下，速度慢）------------------&#34;);
    Iterator&lt;String&gt; iterator1 = map.keySet().iterator();
    while (iterator1.hasNext()){
        String key=iterator1.next();
        System.out.println(key+&#34;::::&#34;+map.get(key));
    }
    //以上两种遍历方式都可以将迭代器方式换成foreach方式。（foreach其实也是调用的iterator）
    //换成foreach其实和用迭代器速度差不多，但foreach更加简洁易懂
    //需要注意的是，只有基于链表实现的容器，遍历才需要避免使用get方式（可用foreach和iterator方式）
}</pre></div>
<p>运行结果如下：</p>

<p><img src="./../media/20191025-1.png" alt="HashMap结果" /></p>

<h3 id="linkedhashmap">LinkedHashMap</h3>

<p>LinkedHashMap是HashMap的子类，此类需要维护元素插入的顺序，以链表来维护内部的顺序，迭代访问时具有不错的性能。一个案例如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">@Test
public void test6(){
    LinkedHashMap&lt;String, Integer&gt; map = new LinkedHashMap&lt;&gt;();
    map.put(&#34;一&#34;,1);
    map.put(&#34;二&#34;,2);
    map.put(&#34;三&#34;,3);
    map.put(&#34;四&#34;,4);
    map.put(&#34;五&#34;,5);
    for (Map.Entry&lt;String,Integer&gt; v:map.entrySet()){
        //对于内部用链表维护的容器，避免使用get方式遍历
        System.out.println(v.getKey()+&#34;::::&#34;+v.getValue());
    }
}</pre></div>
<p>运行结果如下：</p>

<p><img src="./../media/20191025-2.png" alt="LinkedHashMap结果" /></p>

<h3 id="properties类读写属性文件">Properties类读写属性文件</h3>

<p>Hashtable是一个和HashMap很类似类，Hashtable不允许存在键或值为null的映射，其他的和HashMap差不多（但是过于古老，不建议使用）。而Properties则是Hashtable的一个子类。Properties可以将Map对象和属性文件关联起来，可以把Map的键值对写入属性文件中，也可以把属性文件中的 <code>属性=属性值</code> 加载到Map中，同时由于属性文件中的“属性”和“属性值”都是字符串类型的，所以Properties中的键值对都是String类型的。此类提供常用的三个方法：</p>

<ol>
<li>String getProperty(String key)：获取指定键的属性值。</li>
<li>String getPropery(String key,String defaultValue)：获取指定键的属性值，如果不存在，则添加此键的默认值。</li>
<li>Object setProperty(String key,String value)：设置属性值。</li>
<li>void load(InputStream inStream)：从属性文件加载键值对，追加到当前Properties对象。</li>
<li>void store(OutputStream outStream,String comments)：将Properties对象中的键值对输出到指定的属性文件中。comments表示注释。</li>
</ol>

<p>一个测试代码如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">@Test
public void test7() throws IOException {
    Properties properties = new Properties();
    properties.setProperty(&#34;username&#34;,&#34;root&#34;);
    properties.setProperty(&#34;password&#34;,&#34;123456&#34;);
    FileOutputStream out = new FileOutputStream(&#34;res/properties/test.properties&#34;);
    properties.store(out,&#34;just a test~~&#34;);
    //再创建另一个Properties对象，加载刚在创建的属性文件
    Properties properties1 = new Properties();
    properties1.setProperty(&#34;driver&#34;,&#34;mysql8&#34;);
    properties1.load(new FileInputStream(&#34;res/properties/test.properties&#34;));
    //将输出：{password=123456, driver=mysql8, username=root}，可将load是追加方式，而不是覆盖方式
    System.out.println(properties1);
    //再将第二个properties对象写入到xml文件中
    properties1.storeToXML(new FileOutputStream(&#34;res/xml/test.xml&#34;),&#34;只是测试&#34;,&#34;UTF-8&#34;);
}</pre></div>
<p>res/properties/test.properties内容如下图：</p>

<p><img src="./../media/20191025-3.png" alt="属性文件" /></p>

<p>res/xml/test.xml内容如下图：</p>

<p><img src="./../media/20191025-4.png" alt="xml文件" /></p>

<h3 id="sortedmap接口和treemap实现类">SortedMap接口和TreeMap实现类</h3>

<p>Map接口派生出一个SortedMap接口，此接口有一个实现类TreeMap。每个键值对作为一个红黑树的节点，TreeMap里存放的键值对的键的要求和TreeSet一样。具体的往前TreeSet看便知。</p>

<h3 id="identityhashmap">IdentityHashMap</h3>

<p>这个Map实现类的实现机制与HashMap基本相似，但是这个Map比较两个键相等的规则是严格相等（两者通过 <code>==</code> 运算符得到true时）。</p>

<p>一个例子如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">@Test
public void test8(){
    IdentityHashMap&lt;String, Integer&gt; map = new IdentityHashMap&lt;&gt;();
    map.put(new String(&#34;pinger&#34;),18);
    //由于IdentityHashMap判断两个key相等的原则时两者严格相等，所以下面的input能够被添加成功。
    map.put(new String(&#34;pinger&#34;),20);
    //输出：{pinger=20, pinger=18}
    System.out.println(map);
}</pre></div>
<h2 id="各个map实现类比较">各个Map实现类比较</h2>

<ol>
<li>HashMap和Hashtable效率差不多，前者线程不安全，后者线程安全。</li>
<li>TreeMap比HashMap和Hashtable慢，但是其键时有序的（可以利用二分法查找需要的键）。</li>
<li>LinkedHashMap比HashMap慢一点，通过链表维护添加元素的顺序。</li>
<li>IdentityHashMap除了“键严格相等”外无其他特点。</li>
</ol>

<h2 id="collections工具类">Collections工具类</h2>

<p>Collections工具类提供了大量对集合元素进行操作的方法。这些操作去查看java的API文档。此外Collections工具类有两个需要注意的功能：</p>

<ol>
<li>同步控制</li>
<li>设置不可变集合</li>
</ol>

<p>创建线程同步的集合的实例如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">@Test
public void test9(){
    Set&lt;Object&gt; set = Collections.synchronizedSet(new HashSet&lt;&gt;());
    List&lt;Object&gt; list = Collections.synchronizedList(new ArrayList&lt;&gt;());
    Map&lt;Object, Object&gt; map = Collections.synchronizedMap(new HashMap&lt;&gt;());
    Collection&lt;Object&gt; collection = Collections.synchronizedCollection(new TreeSet&lt;&gt;());
}</pre></div>
<p>设置不可变集合的实例如下：</p>
<div class="highlight"><pre style="color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4">@Test
public void test10(){
    //创建一个空的、不可改变的List集合
    List&lt;Object&gt; list = Collections.emptyList();
    //创建只有一个元素的、不可改变的Set集合
    Set&lt;Integer&gt; singleton = Collections.singleton(1);
    Map map=new HashMap();
    map.put(&#34;一&#34;,1);
    map.put(&#34;二&#34;,2);
    //返回上面创建的map的不可变版本
    Map map1 = Collections.unmodifiableMap(map);
}</pre></div>
		</div>

		<div class="post-tags">
			
				
			
		</div><div id="disqus_thread"></div>
<script type="text/javascript">
	(function () {
		
		
		if (window.location.hostname == "localhost")
			return;

		var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
		var disqus_shortname = 'cassie_std';
		dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
		(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
	})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
		Disqus.</a></noscript>
<a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
	<div class="footer wrapper">
	<nav class="nav">
		<div> © Copyright notice |  <a href="https://github.com/vividvilla/ezhil">Ezhil theme</a> | Built with <a href="https://gohugo.io">Hugo</a></div>
	</nav>
</div>

<script>feather.replace()</script>
</body>
</html>
